---
title: docker教程
date: 2024-09-22 21:16:28
permalink: /pages/6dd29e/
categories:
  - Linux
  - Docker
tags:
  - 
author: 
  name: zyg
  link: https://github.com/zyg525
---



## 1、Docker简介

### 什么是Docker？

　　Docker 是基于 Go 语言实现的开源容器项目 它诞生于 2013 年年初，最初发起者是dotCloud 公司。可以将 Docker 容器理解为一种轻量级的沙盒（sandbox），每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致，另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机，很多时候，甚至直接把容器当作应用也没有任何问题。

### Docker有什么用？

　　在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须是“任何时间任何地点”可获取的 因此，开发者们需要一种新型的创建分布式应用程序的方式，**快速分发和部署，而这正是 Docker 所能够提供的最大优势**。
　　举个简单的例子，假设用户试图基于最常见的 LAMP (Linux+Apache+MySQL+PHP ）组合来构建网站 按照传统的做法，首先需要安装 Apache MySQL PHP 以及它们各自运行所依赖的环境；之后分别对它们进行配置（包括创建合适的用户、配置参数等）；经过大量的操作后，还需要进行功能测试，看是否工作正常；如果不正常，则进行调试追踪，意味着更多的时间代价和不可控的风险 可以想象，如果应用数目变多，事情会变得更加难以处理。更为可怕的是， 旦需要服务器迁移（例如从亚马逊云迁移到其他云），往往需要对每个应用都进行重新部署和调试 这些琐碎而无趣的“体力活”，极大地降低了用户的工作效率。究其根源，是这些应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致。而Docker 提供了一种更为聪明的方式，通过容器来打包应用、解藕应用和运行平台，这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台 这无疑将帮助我们节约大 的宝贵时间，并降低部署过程出现问题的风险。

### Docker和虚拟机的对比

　　虚拟 （virtualization）技术是个通用的概念，其核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。虚拟化技术有很多种，常用的VMware Workstation虚拟机就属于“完全虚拟化”，虚拟机模拟完整的底层硬件环境和特权指令的执行过程，而Docker容器则属于“操作系统级虚拟化”，内核通过创建多个虚拟的操作系统实例(内核和库)来隔离不同的进程。操作系统虚拟化最大的特点就是不需要额外的 supervisor 支持。Docker 虚拟化方式之所以有众多优势，跟操作系统虚拟化技术自身的设计和实现是分不开的。

　　下图比较了 Docker 和常见的虚拟机方式的不同之处：

![Docker和常见的虚拟机方式的区别](/myblog/img/java/Docker和常见的虚拟机方式的区别.png)

　　**传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。**

## 2、核心概念与安装配置

### Docker核心概念

　　Docker大部分的操作都围绕着它的三大核心概念：**镜像、容器和仓库**。因此，准确把握这三大核心概念对于掌握 Docker 技术尤为重要。

**Docker镜像**

　　Docker 镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了 Apache 应用程序（或用户需要的其他软件），可以把它称为一个 Apache 镜像。**镜像是创建 Docker 容器的基础**。通过版本管理和增量的文件系统， Docker 提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并直接使用。

**Docker容器**

　　**容器是从镜像创建的应用运行实例**。它可以启动、开始、停止 删除，而这些容器都是彼此相互隔离、互不可见的。可以把容器看作一个简易版的 Linux 系统环境（包括 root 用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。

**Docker仓库**

　　Docker 仓库类似于代码仓库，**是 Docker 集中存放镜像文件的场所**。仓库注册服务器（Registry）是存放仓库的地方，其上往往存放着多个仓库，每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放 Ubuntu 操作系统镜像的仓库，被称为 Ubuntu 仓库，其中可能包括 16.04、18 04 等不同版本的镜像。根据所存储的镜像公开分享与否，
　　Docker 仓库可以分为公开仓库（Public）和私有仓库（Private）两种形式。目前，最大的公开仓库是官方提供的 Docker Hub ，其中存放着数量庞大的镜像供用户下载，国内不少云服务提供商（如腾讯云 阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问。用户如果不希望公开分享自己的镜像文件，Docker 也支持用户在本地网络内创建一个只能自己访问的私有仓库。

>可以看出， Docker 利用仓库管理镜像的设计理念与 Git 代码仓库的概念非常相似，实际上 Docker 设计上借鉴了 Git 的很多优秀思想。

### 安装Docker

这里介绍一下在Centos7系统上安装Docker的步骤。Docker 目前支持 CentOS7 及以后的版本 系统的要求跟 Ubuntu 情况类似， 64 位操作系统，内核版本至少为 3.10。

第一步：安装yum-utils

```
$ sudo yum install -y yum-utils
```
　　如果报错`Could not retrieve mirrorlist http://mirrorlist.centos.org/` ，出现这个错误是因为使用的 CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了你的 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。 

　　解决办法是：
1、

```
cd /etc/yum.repos.d
cp  CentOS-Base.repo   CentOS-Base.repo.backup
```
2、
```
vim CentOS-Base.repo
```
　　注释掉原来的`mirrorlist`和`baseurl`，添加新的`baseurl`分别是
```
baseurl=http://vault.centos.org/7.9.2009/os/$basearch/
baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/
baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/
baseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/
```
3、
　　执行
```
sudo yum clean all
sudo yum makecache
```


第二步：添加Docker稳定版本的yum软件源，这里使用aliyun

```
$ sudo yum-config-manager \
  --add-repo \
  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

第三步：更新yum源缓存，然后安装Docker

```
$ sudo yum update
$ sudo yum install -y docker-ce
```

第四步：启动Docker

```
$ sudo systemctl start docker
```

## 3、使用Docker镜像

　　Docker 运行容器前需要本地存在对应的镜像， 如果镜像不存在， Docker 会尝试先从默认镜像仓库下载（默认使用 Docker Hub 公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。

### 获取镜像

　　从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：

```
$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

　　仓库地址默认是 Docker Hub(docker.io)。仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。

　　例如， 获取一个 Ubuntu 18.04 系统的基础镜像可以使用如下的命令：

```
$ docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
92dc2a97ff99: Pull complete
be13a9d27eb8: Pull complete
c8299583700a: Pull complete
Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
Status: Downloaded newer image for ubuntu:18.04
docker.io/library/ubuntu:18.04
```

　　上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （docker.io）获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。docker pull 命令的输出结果最后一行给出了镜像的完整名称，即： docker.io/library/ubuntu:18.04。

　　下载过程中可以看出 ，镜像文件一般由若干层(layer)组成 ，92dc2a97ff99这样的串是层的唯一id。使用docker pull命令下载中会获取并输出镜像的各层信息。当不同的镜像包括相同的层时，本地仅存储了层的 一份内容，减小了存储空间。

　　下载镜像到本地后， 即可随时使用该镜像了， 例如利用该镜像创建一个容器，在其中运行bash应用， 执行打印 "Hello World"命令：

```
$ docker run -it ubuntu:18.04 bash
root@65663247040f:/# echo "Hello World" 
Hello World
```

### 查看镜像信息

　　可以使用以下命令查看已下载的镜像信息：

```
$ docker image ls [选项]
```

>选项：
>-a：列出所有镜像文件(包括临时文件)，默认为否
>--digests：列出镜像的数字摘要值，默认为否
>-f：过滤列出的镜像
>-q：仅列出镜像ID，通常配合-f对镜像进行批量处理

【例子1】
　　列出所有镜像：

```
$ docker image ls
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
ubuntu               18.04               329ed837d508        3 days ago          63.3MB
```

　　列出名为ubuntu，标签为18.04的镜像：

```
$ docker image ls ubuntu:18.04
```

　　列出在ubuntu:18.04之后建立的镜像(如果要列出之前的镜像，只需把since改成before)：

```
$ docker image ls -f=since=ubuntu:18.04
```

　　列出虚悬镜像。虚悬镜像指的是仓库名和标签名都是`<none>`的镜像，这种镜像是由于镜像更新后，仓库名和标签名被新镜像所占用后产生的，这种镜像没有存在的意义，可以删除：

```
$ docker image ls -f dangling=true
```

**添加镜像标签**

　　可以使用docker tag命令来为本地镜像任意添加新的标签。 例如：

```
$ docker tag ubuntu:18.04 myubuntu:v1
```

　　此时使用docker image ls命令查询镜像，会发现多出来一条myubuntu:v1镜像，它和ubuntu:18.04的ID一样。它们实际上指向了同一个镜像文件，只是别名不同而巳。docker tag命令添加的标签实际上起到了类似链接的作用。

**查看镜像详细信息**

　　可以使用docker inspect命令查看镜像详细信息，包括制作者、适应架构、各层数字摘要等：

```
$ docker inspect ubuntu:18.04
```

**查看镜像创建历史**

　　可以使用docker history命令， 该命令将列出各层的创建信息，后面加上--no-trunc输出完整的信息：

```
$ docker history ubuntu:18.04 --no-trunc
```

* ### 搜索镜像

  使用 docker search 命令可以搜索 Docker Hub 官方仓库中的镜像。 语法为：

```
docker search [选项] keyword
```

>选项：
>-f：过滤输出内容
>--limit int：限制输出结果个数，默认25个

【例子1】
　　搜索官方提供的、带ubuntu关键字的镜像：

```
$ docker search -f=is-official=true ubuntu
```

* ### 删除和清理镜像

  删除镜像的命令格式如下：

```
$ docker image rm IMAGE
```

IMAGE可以是镜像名或镜像ID。

**使用镜像名删除镜像**
　　当同一个镜像文件有多个镜像名(即上一节中的标签)时，删除镜像名并不会删除镜像文件，只是删除了标签而已。但是当镜像文件只有一个镜像名时，此时删除镜像名会连同镜像文件一起删除。

**使用ID删除镜像**
　　使用ID删除镜像，会先尝试删除所有指向该镜像的标签， 然后删除该镜像文件本身。

**强制删除镜像**
　　当有该镜像创建的容器存在时， 镜像文件默认是无法被删除的。如果要强制删除，可以使用-f参数：

```
$ docker image rm -f ubuntu:18.04
```

通常并不推荐使用-f参数来强制删除一个存在容器依赖的镜像。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像。

使用Docker一段时间后， 系统中可能会遗留一些临时的镜像文件， 以及一些没有被使用的镜像， 可以通过docker image prune命令来进行清理：

```
$ docker image prune [选项]
```

>选项：
>-a：删除所有无用镜像，不光是临时镜像
>-f：强制删除镜像

* ### 创建镜像

  创建镜像的方法主要有三种：**基于已有镜像的容器创建、基千本地模板导入、基于Dockerfile创建**。

**基于已有镜像的容器创建**
　　可以使用docker commit命令基于已有镜像的容器创建镜像：

```
$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED       STATUS       PORTS     NAMES
2a5b95ba0667   ubuntu:18.04   "bash"                   2 hours ago   Up 2 hours             hopeful_lewin
$ docker commit -m "添加新文件" -a "zyg" 2a5 myubuntu:v1.0
```

其中，-m后面是提交信息，-a后面是作者信息，2a5是容器ID，myubuntu:v1.0则是新镜像的名字和标签。此时查看本地镜像列表，会发现新创建的镜像已经存在了。

**基于本地模板导入**
　　可以使用docker import命令从本地文件中导入镜像：

```
$ docker import myubuntu.tar -- test/myubuntu:v1.0
```

详见下一章。

**基于Dockerfile创建**
　　基于Dockefile创建是最常见的方式。Dockerfile是一个文本文件，利用给定的指令描述基于某个父镜像创建新镜像的过程。<font color="red">具体将来需要时再学习。</font>

* ### 存出和载入镜像

  **存出镜像**
  　　可以使用docker save命令导出镜像到本地文件：

```
$ docker image ls
REPOSITORY    TAG       IMAGE ID       CREATED          SIZE
newubuntu     v1.0      8469ead27dee   27 minutes ago   194MB
$ docker save 8469 > newubuntu.tar
```

**载入镜像**
　　可以使用docker load命令将存出的镜像再导入到本地镜像库：

```
$ docker load < newubuntu.tar
```

## 4、操作Docker容器

容器是 Docker 的另一个核心概念 简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态。

* ### 创建容器

  **新建容器**
  　　用ubuntu:18.04镜像新建一个容器：

```
$ docker create ubuntu:18.04
bb6f2b706e0bad6fbc6d6a94f4ffbb1b6b7bec1f53f2e4d76d46b5e7ece10026
```

容器创建好后会打印出容器ID，新建的容器处于停止状态，可以使用docker start命令启动。

**启动容器**
　　通过容器ID或其前几位，启动创建好的容器：

```
$ docker start bb6
```

**新建并启动容器**
　　除了创建容器后通过 start 命令来启动，也可以通过run命令直接新建并启动容器。比如：

```
$ docker run ubuntu:18.04 /bin/echo "hello"
hello
```

上面的命令创建并启动了一个容器，并且通过容器输出了hello。

>当利用 docker [container] run 来创建并启动容器时， Docker 在后台运行的标准操作包括：
>1、检查本地是否存在指定的镜像，不存在就从公有仓库下载；
>2、利用镜像创建一个容器，并启动该容器；
>3、分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层
>4、从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；
>5、从网桥的地址池配置一个 IP 地址给容器；
>6、执行用户指定的应用程序；
>7、执行完毕后容器被自动终止。

【例子1】
　　下面的命令启动一个 bash 终端，允许用户进行交互：

```
$ docker run -it ubuntu:18.04 /bin/bash
root@8e14e8bf527e:/# pwd
/
```

其中，-t选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。更多的命令选项可以通过 man docker-run 命令来查看。按下ctrl+d或者输入exit即可退出容器。

**守护态运行**
　　更多的时候，需要让 Docker 容器在后台以守护态（ Daemonized ）形式运行。此时，可以通过添加－d参数来实现。比如，每秒打印一条hello信息，但不在前台显示：

```
$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
a902e52fe5127560a0d3e6ec887ca1cc7e1ab10bd594c0420076c7ce2099faa2
```

容器启动后会返回一个容器ID，也可以通过docker ps命令查看容器信息：

```
$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS     NAMES
a902e52fe512   ubuntu:18.04   "/bin/sh -c 'while t…"   About a minute ago   Up About a minute             funny_chandrasekhar
```

如果要在前台获取容器的输出信息，可以通过docker logs命令：

```
$ docker logs a90
```

后面可以加选项，比如加-f表示持续输出。

* ### 停止容器

  **暂停容器**
  　　可以使用docker pause命令暂停容器：

```
$ docker pause a90
```

然后可以使用docker unpause来恢复运行：

```
$ docker unpause a90
```

**终止容器**
　　可以使用docker stop命令终止一个运行中的容器，比如：

```
$ docker stop a90
```

该命令会首先向容器发送 SIGTERM 信号，等待一段超时时间后（默认为 10 秒），再发送SIGKILL 信号来终止容器。此时，执行 docker container prune 命令，会自动清除掉所有处于停止状态的容器。
　　也可以使用docker kill命令直接发送 SIGKILL 信号来终止容器：

```
$ docker kill a90
```

当 Docker 容器中指定的应用终结时，容器也会自动终止 例如，对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止，处于 stopped 状态。
　　处于终止状态的容器，可以通过docker start命令重新启动：

```
$ docker start a90
```

而docker restart则会将一个正在运行的容器终止，然后重新启动。

* ### 进入容器

  使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。这时候如果要进入容器，推荐使用官方的attach命令或exec命令。

**attach命令**
　　使用attach命令进入容器：

```
$ docker run -itd ubuntu:18.04
0339eb14bcd340f155078c2b04def9a6cf0fb0c7a4be70a034b2dd5fc093018d
$ docker attach 033
root@0339eb14bcd3:/# pwd
/
```

但attach命令有个缺点，当多个窗口同时通过attach命令进入容器时，所有窗口会同步显示信息，同一时间只有一个窗口可以进行操作。

**exec命令**
　　Docker提供了一个更方便的工具exec命令，可以在运行中容器内执行任意命令。
　　使用exec命令进入容器，和attach不同的是，这里需要指定要在容器中执行的命令：

```
$ docker exec -it 033 /bin/bash
root@0339eb14bcd3:/# pwd
/
```

exec命令弥补了attach命令的缺点。

>通过指定-it参数来保持标准输入打开，并且分配一个伪终端，通过exec命令对容器执行操作是最为推荐的方式。

* ### 删除容器

  可以通过docker rm命令删除容器，比如：

```
$ docker rm 033
```

默认情况下，只能删除已终止或退出的容器，如果要删除正在运行的容器，需要加上-f：

```
$ docker rm 033 -f
```

* ### 导入和导出容器

  某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用 Docker 的导人和导出功能，这也是 Docker 自身提供的一个重要特性。

**导出容器**
　　导出容器是指，导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态。
　　导出已有的一个容器到myubuntu.tar文件：

```
$ docker export 033 > myubuntu.tar
```

导出完成后生成myubuntu.tar文件。

**导入容器**
　　导出的tar文件又可以被导入成为镜像文件，此时需要指明镜像名和标签：

```
$ docker import myubuntu.tar -- test/myubuntu:v1.0
```

* ### 查看容器

**查看容器详情**
　　可以使用docker container inspect命令查看容器的具体信息：

```
$ docker container inspect 033
```

**查看容器内进程**
　　可以使用docker top命令查看容器内进程：

```
$ docker top 033
```

**查看统计信息**
　　可以通过docker stats命令查看容器CPU、内存、存储、网络等使用情况的统计信息：

```
$ docker stats 033
```

* ### 其它容器命令

  **复制文件**
  　　可以使用docker cp命令在容器和主机之间复制文件。
  　　将主机中myubuntu.tar文件复制到容器033的/tmp目录中：

```
$ docker cp myubuntu.tar 033:/tmp
```

反之亦然。

**查看变更**
　　可以使用docker container diff命令查看容器内文件系统的变更：

```
$ docker diff 033
```

**查看端口映射**
　　可以使用docker container port命令查看容器内端口的映射情况：

```
$ docker port 033
```

更多的docker命令可通过docker help查看。

## 5、Docker数据管理

在生产环境中使用 Docker ，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。
　　容器中的管理数据主要有两种方式：
　　1、数据卷(Data Volumes)：容器内数据直接映射到本地主机环境；
　　2、数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。

* ### 数据卷

  数据卷 Data Volumes 是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于 Linux 中的 mount 行为。

**创建数据卷**
　　Docker 提供了 volume 子命令来管理数据卷，如下命令可以快速在本地创建一个数据卷：

```
$ docker volume create -d local test
```

此时 ，查看／var/lib/docker/volumes 路径下，会发现所创建的数据卷位置。除了 create 子命令外， docker volume 还支持 inspect（查看详细信息）、ls（列出已有数据卷） prune（清理无用数据卷）、rm（删除数据卷）等。

**绑定数据卷**
　　除了使用 volume 子命令来管理数据卷外，还可以在创建容器时将主机本地的任意路径挂载到容器内作为数据卷，这种形式创建的数据卷称为绑定数据卷。
　　在用 docker [container] run 命令的时候，可以使用 -mount 选项来使用数据卷，-mount 项支持三种类型的数据卷，包括：
　　1、volume：普通数据卷，映射到主机 /var/lib/docker/volumes 路径下；
　　2、bind：绑定数据卷，映射到主机指定路径下；
　　3、tmpfs：临时数据卷，只存在于内存中。

下面创建一个ubuntu容器，并创建一个数据卷/tmp/local挂载到容器的/tmp目录：

```
$ docker run -it --mount type=bind,source=/tmp/local,destination=/tmp ubuntu:18.04
```

也可以使用旧的-v标记：

```
$ docker run -it -v /tmp/local:/tmp ubuntu:18.04
```

本地目录的路径必须是绝对路径，容器内路径可以为相对路径，如果目录不存在，Docker会自动创建。
　　Docker挂载数据卷的默认权限是读写(rw)，用户也可以ro定为只读：

```
$ docker run -it -v /tmp/local:/tmp:ro ubuntu:18.04
```

* ### 数据卷容器

  如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门提供数据卷给其他容器挂载。
  　　首先，创建一个数据卷容器 dbdata 并在其中创建一个数据卷挂载到／dbdata：

```
$ docker run -it -v /dbdata --name dbdata ubuntu:18.04
```

然后，可以在其他容器中使用--volumes-from来挂载 dbdata 容器中的数据卷，例如创建 db1、db2 两个容器，并从 dbdata 容器挂载数据卷：

```
$ docker run -it --volumes-from dbdata --name db1 ubuntu:18.04
$ docker run -it --volumes-from dbdata --name db2 ubuntu:18.04
```

此时， 容器 db1、db2 都挂载同一个数据卷到相同的 /dbdata 目录，三个容器任何一方在该目录下的写人，其他容器都可以看到。
　　可以多次使用--volumes-from参数来从多个容器挂载多个数据卷，还可以从其他已经挂载了容器卷的容器来挂载数据卷：

```
$ docker run -it --volumes-from db1 --name db3 ubuntu:18.04
```

注意，使用--volumes-from参数所挂载数据卷的容器(即上面的dbdata容器)自身并不需要保持运行状态。

* ### 利用数据卷容器来迁移数据

  可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。

**备份**
　　使用下面的命令来备份 dbdata 数据卷容器内的数据卷：

```
$ docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu:18.04 tar cvf /backup/backup.tar /dbdata
```

这条命令首先利用 ubuntu 镜像创建了一个容器 worker。使用--volumes-from dbdata 参数来让 worker 容器挂载 dbdata 容器的数据卷（即dbdata数据卷）；使用 -v $(pwd):/backup 参数来挂载本地的当前目录到 worker 容器的/backup目录。worker 容器启动后，使用 tar cvf /backup/backup.tar /dbdata 命令将／dbdata下内容备份为容器内的／backup/backup.tar ，即宿主主机当前目录下的backup.tar。

**恢复**
　　如果要恢复数据到一个容器，可以按照下面的操作。
　　首先创建一个带有数据卷的容器 dbdata2:

```
$ docker run -v /dbdata --name dbdata2 ubuntu:18.04
```

然后创建另一个新的容器，挂载 dbdata2 容器，并使用 untar 解压备份文件到所挂载的容器卷中：

```
$ docker run --volumes-from dbdata2 -v $(pwd):/backup ubuntu:18.04 tar xvf /backup/backup.tar
```

## 6、端口映射与容器互联

Docker 除了通过网络访问外，还提供了两个很方便的功能来满足服务访问的基本需求：一个是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问。

* ### 端口映射实现容器访问

  在启动容器的时候，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。
  　　当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-p或-P参数来指定端口映射，当使用-P（大写的）标记时，Docker会随机映射一个 49000~49900 的端口到内部容器开放的网络端口：

```
$ docker run -d -P --name ubuntu ubuntu:18.04
```

-p (小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 IP:HostPort:ContainerPort | IP::ContainerPort | HostPort:ContainerPort。
　　使用HostPort:ContainerPort格式将本地的5000端口映射到容器的5000端口，可以执行如下命令：

```
$ docker run -d -p 5000:5000 ubuntu:18.04
```

此时默认会绑定本地所有接口上的所有地址，多次使用-p可以绑定多个端口，比如：

```
$ docker run -d -p 5000:5000 5001:5001 ubuntu:18.04
```

可以使用IP:HostPort:ContainerPort格式指定映射使用一个特定地址，比如：

```
$ docker run -d -p 127.0.0.1:5000:5000 ubuntu:18.04
```

使用IP::ContainerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口：

```
$ docker run -d -p 127.0.0.1::5000 ubuntu:18.04
```

还可以使用udp标记来指定udp端口

```
$ docker run -d -p 127.0.0.1:5000:5000/udp --name ubuntu ubuntu:18.04
```

使用docker port来查看当前映射的端口配置，也可以查看到绑定的地址：

```
$ docker port ubuntu 5000
```

* ### 互联机制实现便捷互访

  容器的互联(linking)是一种让多个容器中的应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。
  　　连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。使用--name标记可以为容器自定义命名。

首先创建一个名为db的数据库容器：

```
$ docker run -d --name db training/postgres
```

然后创建一个名为web的容器，并用--link命令将它连接到db容器：

```
$ docker run -d -P --name web --link db:db training/webapp python app.py
```

--link参数的格式为--link name:alias, 其中name是要链接的容器的名称，alias是别名。

Docker 相当于在两个互联的容器之间创建了一个虚机通道， 而且不用映射它们的端口到宿主主机上。 在启动 db 容器的时候并没有使用 -p 和 -P 标记， 从而避免了暴露数据库服务端口到外部网络上。

可以在 web 容器中安装 ping 命令来测试跟 db 容器的连通：

```
root@d728bbf1a430:/opt/webapp# apt-get install -yqq inetutils-ping
root@d728bbf1a430:/opt/webapp# ping db
PING db (172.18.0.7) 56(84) bytes of data.
64 bytes from db (172.18.0.7): icmp_seq=1 ttl=64 time=0.098 ms
64 bytes from db (172.18.0.7): icmp_seq=2 ttl=64 time=0.059 ms
...
```

用ping来测试db容器，它会解析成172.17.0.7。

用户可以链接多个子容器到父容器，比如可以链接多个web到同一个db容器上。

## 7、Docker仓库

* ### Docker Hub公共仓库

  Docker Hub是 Docker 官方提供的最大的公共镜像仓库，目前包括了超过 100000 的镜像，地址为 https://hub.docker.com 。大部分对镜像的需求，都可以通过在 Docke Hub 中直接下载镜像来实现。

**使用Docker Hub上传和下载镜像的步骤**
　　第一步：注册Docker Hub
　　可以在 https://hub.docker.com 免费注册一个 Docker 账号，并创建一个自己的仓库。

第二步：登录Docker Hub
　　可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。也可以通过 docker logout 退出登录。

第三步：下载镜像
　　可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地，查找或下载官方镜像不需要登录Docker Hub。如：

```
$ docker search ubuntu
NAME                                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   13340     [OK] 
```

可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。
　　根据是否是官方提供，可将镜像分为两类，一种是类似 ubuntu 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。还有一种类型，比如 ansible/ubuntu 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 ansible 用户。
　　下载 ansible/ubuntu 镜像到本地：

```
$ docker pull ansible/ubuntu
```

第四步：上传镜像
　　用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。
　　推送本地镜像到Docker Hub仓库：

```
$ docker push ansible/ubuntu:v1.0
```

* ### 私有仓库

  有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。

**搭建私有仓库的步骤**
　　第一步：安装运行 docker-registry。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录：

```
$ docker run -d \
    -p 5000:5000 \
    --restart=always \
    -v /opt/data/registry:/var/lib/registry \
    registry
```

-p 5000:5000的作用是将容器端口号5000映射到宿主机端口号5000。

第二步：配置非 https 仓库地址。
　　此时如果从一台安装了Docker服务的主机上传镜像到私有仓库，会上传失败，因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制。
　　对于使用 systemd 的Linux系统，可以在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：

```
{
  "registry-mirror": [
    "https://hub-mirror.c.163.com",
    "https://mirror.baidubce.com"
  ],
  "insecure-registries": [
    "46.207.6.117:5000"
  ]
}
```

对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 Docker Engine 中进行编辑 ，增加和上边一样的字符串即可。

第三步：在私有仓库上传、搜索、下载镜像。
　　此时可以从任一一台安装了Docker服务的主机上传镜像到私有仓库所在服务器，如：

```
$ docker tag ubuntu:latest 46.207.6.117:5000/myubuntu:v1.0
$ docker push 46.207.6.117:5000/myubuntu:v1.0
```

这里先将镜像标签改为 `[私有仓库服务器地址:5000]/镜像名`，然后再上传。

还可以用 curl 查看私有仓库中的镜像：

```
$ curl 46.207.6.117:5000/v2/_catalog
```

从私有仓库中下载镜像：

```
$ docker pull 46.207.6.117:5000/myubuntu:v1.0
```

私有仓库还有一些高级配置，可以实现权限认证、TLS等功能，将来需要时再学习。

* ### Nexus3

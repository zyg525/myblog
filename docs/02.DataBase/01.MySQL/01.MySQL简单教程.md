---
title: MySQL教程
categories: 七、数据库
tags: 数据库
layout: post
date: 2024-03-30 13:34:17
permalink: /pages/3a3a84/
author: 
  name: zyg
  link: https://github.com/zyg525
---



## 一、MySQL概述

### 逻辑架构

　　MySQL的逻辑架构如下图所示：

![MySQL逻辑架构图](/myblog/img/java/MySQL逻辑架构图.png)

　　第一层架构包括`连接/线程处理`，主要功能是连接处理、授权认证、安全等。

　　第二层架构包括`查询缓存`、`解析器`、`优化器`，大多数MySQL的核心功能都在这一层，包括查询解析、分析优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

　　第三层架构包括`存储引擎`，存储引擎负责MySQL中数据的存储和提取。MySQL服务器通过API和存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。不同的存储引擎之间不会互相通信，而只是简单地响应上层服务器的请求。

### 并发控制

* #### 读写锁

　　在处理并发读或并发写时，可以通过实现一个由两种数据类型的锁组成的锁系统来解决问题，这两种类型的锁通常被称为**共享锁(shared lock)**和**排他锁(exclusive lock)**，也叫**读锁(read lock)**和**写锁(write lock)**。

　　读写锁的特点是**：多个线程可以同时读取，但不可以读取时写入，也不可以写入时读取、写入时写入。**

* #### 锁粒度

　　在给定的资源上，锁定的数据量越少，系统的并发程度越高，因此要尽量只锁定需要修改的数据，而不是所有资源，从而在锁的开销和数据的安全性之间达到平衡。

　　MySQL提供了多种锁策略，其中**表锁(table lock)**和**行级锁(row lock)**是最重要的两个策略。表锁指的是使用读写锁锁定整张表，它是MySQL中最基本的锁策略，并且是开销最小的锁策略。而行级锁指的是使用读写锁锁定一行，行级锁的并发程度最高，但锁开销也最大。

> info "提示"
>
> 表锁在MySQL服务器层和存储引擎层都可以实现，而行级锁只在存储引擎层实现。

* #### 数据库事务

　　数据库事务指的是一组原子性的SQL，事务内的SQL要么全部执行成功，要么全部执行失败。一个运行良好的事务处理系统，必须有以下四个特性(**ACID特性**)：

　　**1、原子性(atomicity)**：事务中的操作要么全部成功提交，要么全部失败回滚。

　　**2、一致性(consistency)**：事务执行前后数据状态都是合法的。

　　**3、隔离性(isolation)**：通常来说，一个事务在提交之前，它对数据库的修改对其它事务是不可见的。事务不同的隔离级别会影响它的隔离性。

　　**4、持久性(durability)**：一旦事务提交，它所做的修改就会永久保存到数据库中。

　　**原子性、隔离性、持久性是手段，一致性是结果**。事务的ACID特性可以保证银行不会弄丢你的钱，一个兼容ACID的数据库系统，需要做很多复杂但可能用户并没有察觉到的工作，才能确保ACID的实现。

* #### 隔离级别

　　数据库事务的隔离级别指的是，不同事务之间的数据共享程度。**隔离级别越低，系统的并发程度越高，开销也越低，但是数据安全性也越低**。MySQL数据库的四种隔离级别，按照从低到高的顺序如下：

　　**1、READ UNCOMMITED(未提交读)**：一个事务中还没有提交的修改，在另一个事务中是可见的。这会导致**脏读**的出现，即读取到还没有提交的数据。一般这种隔离级别很少使用。

　　**2、READ COMMITED(提交读)**：一个事务中只有提交后的修改，在另一个事务中才是可见的。提交读不会出现脏读，但是会导致**不可重复读**，即在一个事务中进行两次读取，如果有另一个事务在这两次读取之间修改并提交了数据，会导致一个事务中的两次读取结果不一致。这种隔离级别是很多数据库的默认隔离级别，比如Oracle，但MySQL不是。

　　**3、REPEATABLE READ(可重复读)**：一个事务中即使是提交后的修改，更准确地说是更新(UPDATE)操作，在另一个事务中也是不可见的。这种隔离级别解决了不可重复读的问题，但是可能会出现**幻读**的问题。幻读指的是一个事务中提交后的插入、删除，在另一个事务中仍然是可见的。**MySQL的InnoDB引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)解决了幻读的问题。**可重复读是**MySQL数据库的默认隔离级别**。

　　**4、SERIALIZABLE(串行化)**：这是最高的隔离级别，它通过强制事务串行执行，避免了幻读的问题。这种隔离级别很少使用。

> info "提示"
>
> 可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低，虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

### InnoDB存储引擎简介

　　InnoDB是MySQL的默认事务型存储引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其它的存储引擎，否则应该优先考虑InnoDB引擎。

## 二、InnoDB引擎的数据结构

### 数据页简介

　　InnoDB引擎读取磁盘上的数据时，是以数据页为基本单位进行读取的，每个数据页的大小为16KB左右。

### 行格式

　　每个数据页中有若干行，每一行对应着表中的一条记录。目前有四种行格式，分别是Compact、Redundant、Dynamic、Compressed。以Compact为例，它的行格式是：

<img src="/myblog/img/java/InnoDB行格式.png" alt="InnoDB行格式" style="zoom:80%;" />

　　**1、变长字段长度列表**：存放着该行中变长类型字段的每一列实际占用的字节数。

　　**2、NULL值列表**：标记了该行中哪些列的值是NULL，每一列占用一个bit位。

　　**3、记录头信息**：包含了该行的一些描述信息，主要的一些信息如下表所示：

| 名称          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| `delete mask` | 标记该行是否被删除                                           |
| `record_type` | 表示当前记录的类型， 0 表示普通记录(用户行记录)， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3 表示最大记录 |
| `next_record` | 表示下一条记录的相对位置                                     |

### 数据页格式

　　一个数据页的结构如下图所示：

<img src="/myblog/img/java/数据页格式.png" alt="数据页格式" style="zoom:80%;" />

　　**1、Page Header**：存放着页号、上一页的页号、下一页的页号以及其它信息。如果一个表特别大，那么表中的行记录可能分布在多个页中，此时就需要把这些页关联起来，上一页的页号和下一页的页号的作用就是进行关联。**因此，页与页之间构成了双向链表。**

　　**2、Infimum + Supremum**： `Infimum`和`Supremum`分别是最小行记录和最大行记录，它们不存储真实数据，而只是作为标记使用，表中的真实数据存放在`User Records`(用户行记录)中。数据页中的行记录以`Infimum`为头部、`Supremum`为尾部、`User Records`为中间，构成了一个单向链表，**其中`User Records`是按照主键大小升序排列的**，如下图所示：

<img src="/myblog/img/java/行记录构成的单向链表.png" alt="行记录构成的单向链表" style="zoom:67%;" />

　　**3、Page Driectory**：为了提高数据页中行记录的查询效率，将行记录分成了多个小组，每个小组内的记录数不超过8条。将每个小组中最后一条记录的地址偏移量单独拿出来，组成`Page Driectory`(页目录)，偏移量也叫做槽，因此每个页目录都是由一组槽构成的。如下图所示：

<img src="/myblog/img/java/页目录.png" alt="页目录" style="zoom:80%;" />

　　这样在查询行记录时，就可以先使用二分法找到对应的槽，然后找到对应的分组，最后遍历分组中的行记录即可，大大提高了查询效率。

### B+树索引

* #### B+树索引原理

　　当一个表很大时，它的行记录会分布在很多个页中，为了能够快速定位到目标页，将每一页中最小的主键和该页的页号拿出来，放到一个新的页中，这种页叫做索引页，而存放用户行记录的页叫做数据页。索引页中的行记录只存放着对应页的页号和最小主键。当表特别大时，会生成多个索引页，当索引页非常多时，遍历它们的效率会变得很低，此时要为这些索引页生成新的索引页，新的索引页中存放的是旧索引页的页号以及页中最小的主键。

　　以上就是B+树索引的原理，如下图所示：

<img src="/myblog/img/java/B+树索引原理.png" alt="B+树索引原理" style="zoom:80%;" />

　　假设每个数据页中可以存放100条记录，每个索引页中可以存放1000条记录，那么一个4层的B+树索引能够存放`10^11`条记录，远超一个表中的最大记录数，因此B+树索引的层数一般不会超过4层，查询一条记录最多只需要查询4个页面，即3个索引页和1个数据页，在数据页内部还可以通过`Page Directory`来快速定位。

* #### 聚簇索引

　　聚簇索引的特点是：

　　1、记录和页使用主键排序；

　　2、B+树的非叶子节点存放的是下层的页号和页中最小的主键；

　　3、B+树的叶子节点存放的是完整的用户记录。

* #### 二级索引

　　可以给非主键列建立二级索引，二级索引的特点是：

　　1、记录和页使用非主键列排序；

　　2、B+树的非叶子节点存放的是下层的页号和页中最小的非主键列的值；

　　3、B+树的叶子节点存放的是非主键列的值和对应的主键值。

* #### 联合索引

　　还可以给多个列建立联合索引，联合索引的特点是：

　　1、记录和页使用联合索引列排序，对于`index(c1, c2, c3)`，排序规则是：优先使用`c1`排序，如果`c1`相同则使用`c2`排序，如果`c2`相同则使用`c3`排序；

　　2、B+树的非叶子节点存放的是下层的页号和页中最小的联合索引列的值；

　　3、B+树的叶子节点存放的是联合索引列的值和对应的主键值。

　　联合索引本质上也是二级索引。

## 三、索引的用法

### 索引的适用条件

* #### 全值匹配

　　如果查询条件中的字段和索引列完全一致，称为全值匹配。比如在`t_student`表中建立联合索引`index(c1, c2, c3)`，那么下面的查询就是全值匹配：

```sql
SELECT * FROM t_student WHERE c1 = 'a' AND c2 = 'b' AND c3 = 'c';
```

　　对于全值匹配来说，即使查询条件中的字段顺序和索引列不一致，也不影响使用联合索引，因为MySQL优化器会对字段重新排序。

* #### 匹配联合索引左边的列

　　对于联合索引，如果查询条件中包含了索引列左边的几个列，那么也会使用到联合索引。比如在`t_student`表中建立联合索引`index(c1, c2, c3)`，那么下面的查询也会用到联合索引：

```sql
SELECT * FROM t_student WHERE c1 = 'a' AND c2 = 'b';
```

　　在上面的SQL中，会使用`c1`、`c2`两列索引去查询记录。

* #### 匹配字符串索引前缀

　　如果索引列是字符串类型，那么在进行右模糊查询时，也可以使用到索引，因为字符串也是通过一个个字符排序的，就像是一种特殊的联合索引。比如在`t_student`表中有一列`c1`是字符串类型，为它建立索引`index(c1)`，那么下面的查询也会用到索引：

```sql
SELECT * FROM t_student WHERE c1 LIKE 'hello%';
```

* #### 匹配范围值

　　如果是单列索引，并且是范围查询时，会使用到索引，比如下面的查询：

```sql
SELECT * FROM t_student WHERE c1 > 'a' AND c1 < 's';
```

　　如果是联合索引，并且是范围查询时，查询条件中只有联合索引中最左边的一列可以使用到索引，比如下面的查询，对于`index(c1, c2)`，只有`c1`索引列能够生效：

```sql
SELECT * FROM t_student WHERE c1 > 'a' AND c1 < 's' AND c2 > 'A' AND c2 < 'S';
```

　　之所以只有最左边的索引列生效，是因为只有当最左边的索引列相同时，它右边的索引列才是有序的，否则是无序的。

* #### 精确匹配某一列并范围匹配另一列

　　如果是联合索引，并且联合索引最左边的一列是精确匹配，而它右边的一列是范围匹配，这种情况下也可以用到联合索引。比如下面的查询，对于`index(c1, c2)`，`c1`和`c2`索引列都能生效：

```sql
SELECT * FROM t_student WHERE c1 = 'hello' AND c2 > 'A' AND c2 < 'S';
```

* #### 排序

　　使用`ORDER BY`进行排序时，如果排序条件是索引列，那么也会使用索引，因为索引列本来就是有序的，所以可以极大地提高排序的效率。比如：

```sql
SELECT * FROM t_student ORDER BY c1;
```

　　如果是联合索引，在对记录进行排序时，要么排序条件和联合索引完全一致，要么和联合索引的左边几列一致，要么先精确匹配联合索引的左边几列，再对随后的几个索引列进行排序，只有在这些情况下，才会使用到索引。比如对于联合索引`index(c1, c2, c3)`，下面的查询会使用到索引：

```sql
SELECT * FROM t_student WHERE c1 = 'a' ORDER BY c2, c3;
```

* #### 分组

　　使用`GROUP BY`进行分组时，也会使用到索引，规则和排序一样。比如：

```sql
SELECT c1, c2, COUNT(*) FROM t_student GROUP BY c1, c2;
```

### 回表

* #### 什么是回表

　　对于二级索引，它的叶子节点存放的是索引列的值和对应的主键值，在进行查询时，会先从二级索引中查询出主键值，然后用主键值去聚簇索引中查询出用户记录。**用主键值去聚簇索引中查询用户记录的这个过程叫做回表。**

　　二级索引+回表查询的缺点是：

　　1、对于范围查询，在二级索引中是**顺序IO**，因为索引列都是有序的，但是在回表时很可能是**随机IO**，因为主键大概率是无序的，而随机IO的效率比顺序IO的效率低很多，所以回表的效率比较低；

　　2、需要回表的数据越多，使用二级索引的性能越低。

　　查询优化器会对SQL进行分析，如果使用二级索引+回表查询的代价大于全表扫描，就会使用全表扫描进行查询。

* #### 覆盖索引

　　为了避免回表带来的性能消耗，建议将要查询的列包含在索引列中，这样就不需要回表了，这叫做覆盖索引。

### 怎样创建和使用索引

　　为了能够高效地利用索引进行查询，建立索引时应该尽量遵守下面的规则：

　　1、只为用于查询、排序、分组的列创建索引；

　　2、尽量为基数大(不重复值的数量)的列创建索引；

　　3、索引列的类型尽量小，因为这样一个索引页中才能容纳更多的索引列，从而减少磁盘IO的次数，而且类型越小，CPU计算的越快；

　　4、因为字符串比较长，所以当索引列是字符串类型时，尽量只将它的前几个字符作为索引；

　　5、不要在查询条件中对索引列进行四则运算、函数运算，这会导致索引失效；

　　6、插入记录时，最好让主键自增，因为如果主键是无序插入，会导致频繁的页分裂，影响性能；

　　7、不要创建多余的索引。

## 四、EXPLAIN执行计划

### 概述

　　一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行
计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行
查询等等。MySQL为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划，

　　比如执行下面的语句：

```sql
EXPLAIN SELECT * FROM t_student WHERE c1 = 'hello';
```

　　就会生成下面的结果：

![EXPLAIN执行计划](/myblog/img/java/EXPLAIN执行计划.png)

### 执行计划中的各个列

| 列名                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `id`                   | 每个`SELECT`语句都对应一个`id`，相同的`id`从上往下执行，不同的`id`从大到小执行 |
| `select_type`          | 每个`SELECT`语句都对应一个`select_type`，`select_type`分为以下几类：<br />1、`SIMPLE`：单表查询，即不包含`UNION`查询或子查询；<br />2、`PRIMARY`：如果包含`UNION`查询或子查询，那么最左边的查询的`select_type`就是`PRIMARY`；<br />3、`UNION`：如果包含`UNION`查询或子查询，那么除了最左边的查询，其它查询的`select_type`就是`UNION`；<br />4、`UNION_RESULT`：如果是`UNION ALL`查询，那么会使用临时表来去重，该临时表的`select_type`就是`UNION RESULT`；<br />5、其它类型：`SUBQUERY`、`DEPENDENT SUBQUERY`、`DEPENDENT UNION`、`DERIVED`、`MATERIALIZED`。 |
| `table`                | 表名                                                         |
| `type`                 | 对该表的访问方式，主要分为以下几种：<br />1、`system`：表中只有一行记录时的访问方式，很少出现；<br />2、`const`：当查询条件是唯一索引列与一个常数的等值比较时，访问方式就是`const`，在这种情况下最多只会匹配到一条记录；<br />3、`ref`：当查询条件是非唯一索引列与一个常数的等值比较时，访问方式就是`ref`，在这种情况下可能会匹配到多条记录；<br />4、`ref_or_null`：当查询条件中包含二级索引列与`NULL`的等值比较，并且没有全表扫描时，访问方式就是`ref_or_null`；<br />5、`eq_ref`：在连接查询时，当被驱动表是通过主键或者非空唯一二级索引列等值匹配时，则驱动表的访问方式就是`eq_ref`，如果二级索引列是联合索引，那么联合索引列中的每一列都要等值匹配，因为只有这样才能保证驱动表中的任意一条记录最多只能匹配到被驱动表中的一条记录，这就是`eq`的含义；<br />6、`index_merge`：表示查询使用到了两个及以上的索引，最后取交集或并集；<br />7、`range`：当查询条件是范围查询时，并且使用到了索引，那么访问方式就是`range`；<br />8、`index`：遍历索引树的叶子节点，这种方式比`ALL`(全表扫描)快一些，虽然都是遍历，但`index`是从索引中读取，而全表扫描是从硬盘中读取；<br />9、`ALL`：全表扫描，查询效率最低；<br />10、其它类型：`fulltext`(全文索引)、`unique_subquery`、`index_subquery`。 |
| `possible_keys`和`key` | `possible_keys`代表可能用到的索引，`key`代表经查询优化器计算成本后，实际用到的索引 |
| `key_len`              | 实际使用索引列的最大可能长度，而非真实长度                   |
| `ref`                  | 当查询条件属于等值匹配时，也就是当`type`是`const`、`ref`、`ref_or_null`、`eq_ref`、`unique_subquery`、`index_subquery`其中之一时，`ref`指的就是等值匹配的对象，比如是一个常数`const`还是某个列 |
| `rows`                 | 估算出的扫描行数，行数越少，查询越快                         |
| `filtered`             | 返回结果的行数占需要扫描行数的百分比，这是一个估计值，并不准确。`filtered`越大，说明查询效率越高 |
| `Extra`                | 一些重要的额外信息：<br />1、`Using filesort`：当使用`order by`排序，而没有用到索引时，效率比较低；<br />2、`Using Temporary`：当使用了临时表保存中间结果时，常见于`order by`和`group by`；<br />3、`Using index`：当在查询列表中使用了覆盖索引时；<br />4、`Using where`：当使用了`where`过滤时；<br />5、`Impossible WHERE`：当`where`中的判断结果永远是`false`时；<br />6、其它类型：`Using join buffer`、`select tables optimized away`、`distinct`。 |


---
title: SQL语句优化要点
date: 2024-07-11 16:54:23
permalink: /pages/fe49ea/
categories:
  - DataBase
  - MySQL
tags:
  - 
author: 
  name: zyg
  link: https://github.com/zyg525
---
## 一、分页查询优化

　　假设表中有500万条记录，现在要查询出第4000001到4000010条记录，一般的写法是：

```sql
SELECT * FROM t_student ORDER BY id LIMIT 4000000, 10;
```

　　但是这种写法的查询速度很慢，原因是MySQL会先查询出第1到第4000010条记录，然后扔掉前4000000条记录，只留下后面的10条记录，前4000000条记录相当于无效查询。

　　分页查询优化的方法有以下几种：

- 记录offset

```sql
SELECT * FROM t_student WHERE id>4000000 ORDER BY id LIMIT 10;
```

- between...and

```sql
SELECT * FROM t_student WHERE id BETWEEN 4000001 AND 4000010 ORDER BY id;
```

- 覆盖索引+子查询

```sql
SELECT * FROM t_student WHERE id>= (SELECT id FROM t_student LIMIT 4000000, 1) ORDER BY id LIMIT 10;
```

- 延迟关联

```sql
SELECT * FROM t_student t1 INNER JOIN (SELECT id FROM t_student LIMIT 4000000, 10) t2 ON t1.id=t2.id ORDER BY id;
```

　

　　**几种方法的比较**：

　　假如id是连续的，那么在最原始的写法`SELECT * FROM t_student ORDER BY id LIMIT 4000000, 10`中，最终查询出来的是id=4000001到id=4000010之间的10条记录。如果id是不连续的，比如id=1的记录缺失，那么实际上查询出来的是id=4000002到id=4000011之间的10条记录，这也是在分页查询中我们想要的结果。

　　但是在前两种方法中，当id=1的记录缺失时，实际查询出来的还是id=4000001到id=4000010之间的10条记录。对于记录offset这种方法，如果有很多个记录都缺失了，那么在分页中就会出现很多重复的查询结果。而对于`between..and`这种方法，当缺失的id位于4000001到4000010之间时，会导致查询出的记录不足10条，这不符合数据分页的要求。

　　在后两种方法中，由于子查询使用的是最原始的写法，因此可以保证查询出的id一定符合实际的次序（比如子查询查出来的第4000001个id，不管表中缺失了多少记录，这4000001个记录一定是存在的），所以分页中不会出现重复或者缺失的情况。这里讲的比较拗口，但是总之一句话，**当id不连续时，要采用后两种方法进行分页。**

## 二、小表驱动大表

　　两张表进行连接查询时，使用小表驱动大表可以提高查询速度，因为连接查询的本质是先查出一张表中的数据，然后用每一条数据去另一张表中查询，假设先查询的是表A，后查询的是表B，那么连接查询的逻辑如下：

```
for(表A) {
	for(表B) {
		A.id = B.id;
	}
}
```

　　在这个过程中，表A只需要查询一次，表B查询的次数等于从表A中查询出来的记录数，因此表A越小，总的查询次数越少，查询速度也就越快。先查询的表叫做驱动表，后查询的表叫做被驱动表，所以我们说要用小表驱动大表。为了进一步提高连接查询的速度，可以给字段加上合适的索引。

　　连接查询的类型有下面几种：

- left join

　　A是驱动表，B是被驱动表，因此A表应该比B表小。

```sql
SELECT A.* FROM A LEFT JOIN B ON A.id=B.id;
```

- right join

　　B是驱动表，A是被驱动表，因此B表应该比A表小。

```sql
SELECT B.* FROM A RIGHT JOIN A ON B.id=A.id;
```

- inner join

　　MySQL会自动选择A和B中较小的一张表作为驱动表。

```sql
SELECT A.* FROM A INNER JOIN B ON A.id=B.id;
```

- where in

　　B是驱动表，A是被驱动表，因此B表应该比A表小。

```sql
SELECT * FROM A WHERE id IN (SELECT id FROM B WHERE B.id>100);
```

- where exists

　　A是驱动表，B是被驱动表，因此A表应该比B表小。

```sql
SELECT A.* FROM A WHERE EXISTS (SELECT 1 FROM B WHERE B.id>100 AND A.id=B.id);
```


---
title: 牛客面试必刷TOP101
date: 2025-02-04 12:40:57
permalink: /pages/574a30/
categories:
  - 计算机基础
  - 算法
tags:
  - 
author: 
  name: zyg
  link: https://github.com/zyg525
---
## 一、链表

### 1、反转链表

**题目**：

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0≤n≤1000

要求：空间复杂度 O(1)，时间复杂度 O(n)。

如当输入链表{1,2,3}时，经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

**解法**：

创建两个节点的引用left和right，left指向当前节点的上一个节点，right指向当前节点的下一个节点，每次都让当前节点指向left。

时间复杂度O(n)，空间复杂度O(1)。

> **关键词**：`临时节点left、right`，`当前节点head`，`head指向left`。

### 2、链表内指定区间反转

**题目**：

将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。
例如：
给出的链表为 1→2→3→4→5→NULL    *m*=2,*n*=4,
返回 1→4→3→2→5→NULL

　　

数据范围： 链表长度 0<size≤1000，0<m≤n≤size，链表中每个节点的值满足 ∣val∣≤1000

要求：时间复杂度 O(n)，空间复杂度 O(n)

进阶：时间复杂度 O(n)，空间复杂度 O(1)

**解法**：

类似于普通的链表反转，但是只反转[m, n]之间的节点。同时要保存m-1、m、n、n+1的节点，反转完成后，让m-1指向n，让m指向n+1。最后要注意当m=1时，最后要返回的是n节点，当m!=1时，要返回的是头节点。

时间复杂度O(n)，空间复杂度O(1)。

> **关键词**：`类似于普通反转`，`m-1、m、n、n+1`，`注意m=1的情况`。

### 4、合并两个排序的链表

**题目**：

输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。

数据范围： 0≤n≤1000，−1000≤节点值≤1000
要求：空间复杂度 O(1)，时间复杂度 O(n)

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}

**解法1**：

创建一个临时节点head，让cur指针指向head，同时遍历两个链表，并比较它们的节点，让cur指向其中的较小者，并将较小者作为新的cur，直到某一链表节点为空，此时让该链表的尾节点指向另一个链表剩下节点中的第一个节点，最后返回head.next即可。

时间复杂度O(n)，空间复杂度O(1)。

> **关键词**：`临时节点head`，单指针`cur`，`pre指向min(phead1, phead2)`，`min(phead1, phead2)又作为新的pre`，`链表1的尾节点指向链表2剩下的节点`。

**解法2**：

递归。如果其中一个链表为空，返回另一个链表；如果都不为空，比较head1和head2，假如head1<head2，则head1作为头节点，head1的下一个节点就是head1.next与head2中的较小者，否则就是head2作为头节点，head2的下一个节点就是head2.next与head1中的较小者，用这种方式来递归。

时间复杂度O(n)，空间复杂度O(n)。

> **关键词**：`递归`。

### 5、合并k个已排序的链表

**题目**：

合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。

数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣<=1000

要求：时间复杂度 O(nlogn)

**解法**：

以合并两个有序链表的方法为基础，通过递归分而治之，每次递归时将数组一分为二，直到分成两个或者一个元素，若分成两个元素，则返回它们的合并结果，若分成一个元素，则返回该元素。

时间复杂度O(nlog n)，空间复杂度O(log n)。

> **关键词**：`递归`，`二分法`，`分而治之`，`以合并两个有序链表的方法为基础`。
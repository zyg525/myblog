(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{460:function(t,a,v){"use strict";v.r(a);var _=v(4),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("面向对象系统的设计追求的有两点："),a("strong",[t._v("高内聚、低耦合")]),t._v("。本文Java代码已上传到GitHub："),a("a",{attrs:{href:"https://github.com/zyg525/design-parttern.git",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/zyg525/design-parttern.git"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"一、创建型模式-creational"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、创建型模式-creational"}},[t._v("#")]),t._v(" 一、创建型模式(creational)")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"工厂模式-factory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式-factory"}},[t._v("#")]),t._v(" 工厂模式(factory)")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"_1、静态工厂-static-factory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、静态工厂-static-factory"}},[t._v("#")]),t._v(" 1、静态工厂(static-factory)")])])]),t._v(" "),a("p",[t._v("静态工厂是最简单的工厂模式，它也叫做简单工厂。"),a("strong",[t._v("静态工厂的核心是，将复杂对象的创建过程封装到工厂类的静态方法中，调用者通过调用这个静态方法创建对象")]),t._v("。")]),t._v(" "),a("p",[t._v("创建多种对象时，有两种方法：一是将所有对象的创建过程都写在一个静态方法中，然后在方法参数中传入对象类型，通过"),a("code",[t._v("if...else")]),t._v("来返回不同的对象；二是将不同对象的创建过程写在不同的静态方法中。")]),t._v(" "),a("p",[t._v("静态工厂的缺点是，当新增一种对象时，需要修改原有的静态工厂方法，"),a("strong",[t._v("只实现了高内聚，没有实现低耦合")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"_2、工厂方法-factory-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、工厂方法-factory-method"}},[t._v("#")]),t._v(" 2、工厂方法(factory-method)")])])]),t._v(" "),a("p",[t._v("工厂方法可以认为是对静态工厂的一种改进，"),a("strong",[t._v("它们的区别是工厂中不再使用静态方法，而是实例方法，并且工厂类需要实现工厂接口")]),t._v("。")]),t._v(" "),a("p",[t._v("和静态工厂一样，创建多种对象时，也有同样的两种方法，这里不再赘述。")]),t._v(" "),a("p",[a("strong",[t._v("工厂方法由于实现了工厂接口，因此当新增一种对象时，不需要修改原来的工厂方法，只需要针对新对象新增一个工厂实现类即可。实现了高内聚、低耦合")]),t._v("。"),a("code",[t._v("if...else")]),t._v("的逻辑交给了调用者。")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"_3、抽象工厂-abstract-factory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、抽象工厂-abstract-factory"}},[t._v("#")]),t._v(" 3、抽象工厂(abstract-factory)")])])]),t._v(" "),a("p",[t._v("静态工厂和工厂方法都是针对单个产品族的工厂模式。所谓产品族，就是一系列不同但存在关联的产品集合，比如苹果产品族包括苹果电脑、苹果手机，华为产品族包括华为电脑、华为手机，电脑和手机是不同的对象，苹果电脑和华为电脑也是不同的对象，但是华为电脑和华为手机可能会存在一些关联，比如华为的协同工作技术。"),a("strong",[t._v("抽象工厂和工厂方法最主要的区别是，抽象工厂针对的是多个产品族，而工厂方法只针对一个产品族")]),t._v("。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("工厂模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、Spring容器用到了工厂模式，创建Bean对象的方法是"),a("code",[t._v("BeanFactory.getBean(Class var)")]),t._v("；")]),t._v(" "),a("p",[t._v("2、MyBatis中创建SqlSession时也用到了工厂模式，创建SqlSession对象的方法是"),a("code",[t._v("SqlSessionFactory.openSession()")]),t._v("；")]),t._v(" "),a("p",[t._v("3、JDBC中创建数据库连接Connection时也用到了工厂模式，创建Connection对象的方法是"),a("code",[t._v("DriverManager.getConnection(String url,String username,String password)")]),t._v(";")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"建造者模式-builder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式-builder"}},[t._v("#")]),t._v(" 建造者模式(builder)")])])]),t._v(" "),a("p",[t._v("初始化一个对象可以通过构造方法或者setter方法实现，但是当一个对象的属性较多并且某些属性不一定需要时，如果使用构造方法初始化对象，需要定义很多构造方法，如果使用setter方法构造，由于多个set方法是非链式调用，因此很容易出错。使用建造者模式可以解决这个问题。")]),t._v(" "),a("p",[t._v("使用建造者模式的步骤是：")]),t._v(" "),a("p",[t._v("1、在对象类中创建一个静态内部类"),a("code",[t._v("Builder")]),t._v("；")]),t._v(" "),a("p",[t._v("2、在内部类中定义和外部类一样的属性，对对象中必有的属性创建构造方法，对不一定有的属性创建set方法，并返回内部类this对象；")]),t._v(" "),a("p",[t._v("3、在外部类中定义构造方法，参数是内部类对象，在构造方法中将内部类属性值复制给外部类属性；")]),t._v(" "),a("p",[t._v("4、在内部类中定义"),a("code",[t._v("build()方法")]),t._v("，在方法中调用外部类构造方法，传入内部类this对象，返回外部类对象。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("建造者模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、JDK中的StringBuilder就用到了建造者模式，可以链式调用"),a("code",[t._v("append")]),t._v("方法，并且对于不同的调用顺序创建出不同的对象。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"单例模式-singleton"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式-singleton"}},[t._v("#")]),t._v(" 单例模式(singleton)")])])]),t._v(" "),a("p",[t._v("单例模式的重点在于，在多线程环境下，保证系统中只存在一个实例。")]),t._v(" "),a("p",[t._v("单例模式有饿汉式和懒汉式两种，其中饿汉式在类加载的时候就创建了实例，懒汉式只有在调用方法后才会创建实例。还有一种枚举类写法，可以避免反射、反序列化的破解，但用的比较少。")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"_1、饿汉式写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、饿汉式写法"}},[t._v("#")]),t._v(" 1、饿汉式写法")])])]),t._v(" "),a("p",[t._v("1、在成员变量中初始化单例，并将其私有化；")]),t._v(" "),a("p",[t._v("2、私有化构造方法；")]),t._v(" "),a("p",[t._v("3、创建静态方法，作为外界获取单例的唯一方式。")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"_2、懒汉式写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、懒汉式写法"}},[t._v("#")]),t._v(" 2、懒汉式写法")])])]),t._v(" "),a("p",[t._v("懒汉式写法包括"),a("strong",[t._v("双重检验锁和静态内部类")]),t._v("两种。")]),t._v(" "),a("p",[t._v("双重检验锁需要注意的地方是："),a("strong",[t._v("成员变量要用volatile修饰，在双重非null检验之间进行同步")]),t._v("。")]),t._v(" "),a("p",[t._v("静态内部类的写法是，创建一个静态内部类，在内部类中定义成员变量并初始化，在外部类中创建静态方法，返回内部类中的成员变量。"),a("strong",[t._v("静态内部类只有在使用时才会被装载，因此可以实现饿汉式")]),t._v("。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("单例模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、Spring容器中的Bean默认都是单例的，即对于同一个容器，里面的Bean实例是唯一的。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"原型模式-prototype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型模式-prototype"}},[t._v("#")]),t._v(" 原型模式(prototype)")])])]),t._v(" "),a("p",[t._v("根据现有对象的拷贝，创建新的对象。")]),t._v(" "),a("h2",{attrs:{id:"二、结构型模式-structural"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、结构型模式-structural"}},[t._v("#")]),t._v(" 二、结构型模式(structural)")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"适配器模式-adapter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式-adapter"}},[t._v("#")]),t._v(" 适配器模式(adapter)")])])]),t._v(" "),a("p",[t._v("适配器模式用于将一种接口转换为另一种接口。")]),t._v(" "),a("p",[t._v("如果要将接口A转换为接口B，实现适配器模式的步骤是：")]),t._v(" "),a("p",[t._v("1、创建适配器类，让它实现接口B，并在成员变量中持有一个接口A的实例，通过构造方法初始化；")]),t._v(" "),a("p",[t._v("2、重写接口B的方法，在该方法中调用接口A的方法。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("适配器模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、Spring的AOP用到了适配器模式。 //TODO")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"桥接模式-bridge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式-bridge"}},[t._v("#")]),t._v(" 桥接模式(bridge)")])]),t._v(" "),a("li",[a("h3",{attrs:{id:"组合模式-composite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合模式-composite"}},[t._v("#")]),t._v(" 组合模式(composite)")])]),t._v(" "),a("li",[a("h3",{attrs:{id:"装饰者模式-decorator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式-decorator"}},[t._v("#")]),t._v(" 装饰者模式(decorator)")])])]),t._v(" "),a("p",[t._v("当我们需要在运行期动态地给一个对象增加额外功能，并且不想使用继承时，可以使用装饰者模式。"),a("strong",[t._v("装饰者模式的核心是，装饰类和被装饰类都要实现同一个接口，并且装饰类要持有一个被装饰类的引用，在构造方法中初始化这个引用，然后在方法中通过这个引用调用被装饰类的方法。")])]),t._v(" "),a("p",[a("strong",[t._v("装饰者模式和代理模式的写法很像，它们的区别也很明显，代理模式往往只会写一个代理类，但装饰者模式往往有很多装饰者类，原因是代理模式要解决的问题是”代理“，而一个对象只能有一个代理，装饰者模式要解决的问题是”装饰“，一个对象很有可能被多次装饰")]),t._v("。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("装饰者模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、在JDK的IO中大量用到了装饰者模式，比如字符输入流"),a("code",[t._v("InputStreamReader")]),t._v("实际上是通过所持有的字节输入流"),a("code",[t._v("InputStream")]),t._v("来读取字节信息的，然后再将字节按照编码转换为字符。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"外观模式-facade"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#外观模式-facade"}},[t._v("#")]),t._v(" 外观模式(facade)")])])]),t._v(" "),a("p",[t._v("当你的程序中有很多子模块或子系统，而你需要为这些子模块提供一个统一的访问界面时，可以使用外观模式。外观模式体现了高内聚的设计思想。")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"享元模式-flyweight"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#享元模式-flyweight"}},[t._v("#")]),t._v(" 享元模式(flyweight)")])])]),t._v(" "),a("p",[t._v("享元模式的作用是，尝试重复使用现有的同类对象，以节省内存。共享对象有内部状态和外部状态，内部状态共享，外部状态不共享，由客户端传入。")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"代理模式-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理模式-proxy"}},[t._v("#")]),t._v(" 代理模式(proxy)")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"_1、静态代理-static-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、静态代理-static-proxy"}},[t._v("#")]),t._v(" 1、静态代理(static-proxy)")])])]),t._v(" "),a("p",[t._v("静态代理指的是代理关系在编译期就已经确定了，其写法是创建好代理类和被代理类，然后实现同一个接口，同时代理类持有一个被代理类的引用，通过这个引用来增强被代理类的方法。")]),t._v(" "),a("ul",[a("li",[a("h4",{attrs:{id:"_2、动态代理-dynamic-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、动态代理-dynamic-proxy"}},[t._v("#")]),t._v(" 2、动态代理(dynamic-proxy)")])])]),t._v(" "),a("p",[t._v("动态代理指的是代理关系在运行期才确定，其实现方式包括JDK动态代理和cglib动态代理，在JDK动态代理中，我们需要创建被代理类，然后创建Handler类，在这个类中写上我们要增强的逻辑，然后让JDK帮我们在运行期自动生成代理类。"),a("strong",[t._v("因此，在动态代理中，不需要手动编写被代理类或手动编写代理关系")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("代理模式和装饰者模式非常像，它们之间最大的区别是，装饰者模式强调增强对象的功能，而代理模式强调控制对象的访问。")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("代理模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、Spring中的AOP就用到了动态代理。")])]),t._v(" "),a("h2",{attrs:{id:"三、行为型模式-behavioral"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、行为型模式-behavioral"}},[t._v("#")]),t._v(" 三、行为型模式(behavioral)")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"责任链模式-chain-of-responsibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式-chain-of-responsibility"}},[t._v("#")]),t._v(" 责任链模式(chain-of-responsibility)")])])]),t._v(" "),a("p",[t._v("责任链模式把多个处理器串成链，然后让请求在链上传递。写法是定义多个处理器类，在每个处理器类中定义"),a("code",[t._v("setNextHandler")]),t._v("方法指定下游处理器，定义"),a("code",[t._v("handle")]),t._v("方法处理请求。最终请求只能被链中的一个处理器处理。")]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"命令模式-command"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令模式-command"}},[t._v("#")]),t._v(" 命令模式(command)")])]),t._v(" "),a("li",[a("h3",{attrs:{id:"迭代器模式-iterator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式-iterator"}},[t._v("#")]),t._v(" 迭代器模式(iterator)")])])]),t._v(" "),a("p",[t._v("迭代器模式用于顺序访问集合对象的元素，而不需要知道集合对象的底层表示。迭代器的写法是，集合类实现"),a("code",[t._v("Iterable")]),t._v("接口，并重写"),a("code",[t._v("iterator()")]),t._v("方法，这个方法中会返回一个"),a("code",[t._v("Iterator")]),t._v("对象，"),a("code",[t._v("Iterator")]),t._v("接口中定义了遍历集合元素的"),a("code",[t._v("hasNext()")]),t._v("和"),a("code",[t._v("next()")]),t._v("等方法，因此还要定义一个内部类，实现"),a("code",[t._v("Iterator")]),t._v("接口，并重写"),a("code",[t._v("hasNext()")]),t._v("和"),a("code",[t._v("next()")]),t._v("等方法，在这些方法中自定义遍历元素逻辑。遍历集合元素时，只需要调用"),a("code",[t._v("iterator()")]),t._v("方法，通过"),a("code",[t._v("Iterator")]),t._v("对象进行遍历即可，无需了解集合中元素的存储细节。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("迭代器模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、JDK的集合类中就用到了迭代器模式，比如"),a("code",[t._v("List")]),t._v("中就定义了"),a("code",[t._v("iterator()")]),t._v("方法，用于返回遍历集合的"),a("code",[t._v("Iterator")]),t._v("对象。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"备忘录模式-memento"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式-memento"}},[t._v("#")]),t._v(" 备忘录模式(memento)")])]),t._v(" "),a("li",[a("h3",{attrs:{id:"观察者模式-observer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式-observer"}},[t._v("#")]),t._v(" 观察者模式(observer)")])])]),t._v(" "),a("p",[t._v("观察者模式也叫做"),a("strong",[t._v("发布-订阅模式")]),t._v("。通常会定义一个生产者和多个消费者，生产者可以添加消费者作为订阅者，生产者属性发生变化后通知所有的订阅者，生产者也可以移除某个订阅者。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("观察者模式在Java中的应用有")]),t._v("：")]),t._v(" "),a("p",[t._v("1、Spring中的监听器就用到了观察者模式； //TODO")]),t._v(" "),a("p",[t._v("2、各种消息中间件也都用到了观察者模式。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"策略模式-strategy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#策略模式-strategy"}},[t._v("#")]),t._v(" 策略模式(strategy)")])])]),t._v(" "),a("p",[t._v("策略模式定义了一组算法，然后将每一个算法封装起来，使用时可以互相替换。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[t._v("策略模式在Java中的应用有：")]),t._v(" "),a("p",[t._v("1、Spring容器在实例化对象的时候用到了策略模式。 //TODO")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"状态模式-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态模式-state"}},[t._v("#")]),t._v(" 状态模式(state)")])]),t._v(" "),a("li",[a("h3",{attrs:{id:"模板方法模式-template-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式-template-method"}},[t._v("#")]),t._v(" 模板方法模式(template-method)")])])]),t._v(" "),a("p",[t._v("模板方法模式的核心思想是："),a("strong",[t._v("父类定义骨架、子类实现细节")]),t._v("。模板模式的的写法是，先创建模板类，一般是一个抽象类，在模板类中定义骨架方法，即可以重复使用的方法，并将骨架方法设为final类型，禁止子类重写，然后再定义一些抽象方法，供子类重写，不同的子类有不同的实现方式，此外还可以定义一些钩子方法，所谓钩子方法就是方法体中不做任何事的方法，子类可以重写这些方法，也可以不重写，较为灵活。")]),t._v(" "),a("p"),t._v(" "),a("blockquote",[a("p",[t._v("模板方法模式在Java中的应用有：")]),t._v(" "),a("p",[t._v("1、各种和网络连接相关的"),a("code",[t._v("*Template")]),t._v("类都用到了模板方法模式，比如"),a("code",[t._v("JdbcTemplate、RedisTemplate、AmqpTemplate")]),t._v("等，这些类会将创建连接、释放连接等公共操作抽取出来放在父类中，让子类去实现非公共操作。")])]),t._v(" "),a("ul",[a("li",[a("h3",{attrs:{id:"访问者模式-visitor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问者模式-visitor"}},[t._v("#")]),t._v(" 访问者模式(visitor)")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);
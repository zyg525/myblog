(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{428:function(_,v,e){"use strict";e.r(v);var t=e(4),n=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"一、链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、链表"}},[_._v("#")]),_._v(" 一、链表")]),_._v(" "),v("h3",{attrs:{id:"_1、反转链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、反转链表"}},[_._v("#")]),_._v(" 1、反转链表")]),_._v(" "),v("p",[v("strong",[_._v("题目")]),_._v("：")]),_._v(" "),v("p",[_._v("给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。")]),_._v(" "),v("p",[_._v("数据范围： 0≤n≤1000")]),_._v(" "),v("p",[_._v("要求：空间复杂度 O(1)，时间复杂度 O(n)。")]),_._v(" "),v("p",[_._v("如当输入链表{1,2,3}时，经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。")]),_._v(" "),v("p",[v("strong",[_._v("解法")]),_._v("：")]),_._v(" "),v("p",[_._v("创建两个节点的引用left和right，left指向当前节点的上一个节点，right指向当前节点的下一个节点，每次都让当前节点指向left。")]),_._v(" "),v("p",[_._v("时间复杂度O(n)，空间复杂度O(1)。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("关键词")]),_._v("："),v("code",[_._v("临时节点left、right")]),_._v("，"),v("code",[_._v("当前节点head")]),_._v("，"),v("code",[_._v("head指向left")]),_._v("。")])]),_._v(" "),v("h3",{attrs:{id:"_2、链表内指定区间反转"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、链表内指定区间反转"}},[_._v("#")]),_._v(" 2、链表内指定区间反转")]),_._v(" "),v("p",[v("strong",[_._v("题目")]),_._v("：")]),_._v(" "),v("p",[_._v("将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。\n例如：\n给出的链表为 1→2→3→4→5→NULL    "),v("em",[_._v("m")]),_._v("=2,"),v("em",[_._v("n")]),_._v("=4,\n返回 1→4→3→2→5→NULL")]),_._v(" "),v("p"),_._v(" "),v("p",[_._v("数据范围： 链表长度 0<size≤1000，0<m≤n≤size，链表中每个节点的值满足 ∣val∣≤1000")]),_._v(" "),v("p",[_._v("要求：时间复杂度 O(n)，空间复杂度 O(n)")]),_._v(" "),v("p",[_._v("进阶：时间复杂度 O(n)，空间复杂度 O(1)")]),_._v(" "),v("p",[v("strong",[_._v("解法")]),_._v("：")]),_._v(" "),v("p",[_._v("类似于普通的链表反转，但是只反转[m, n]之间的节点。同时要保存m-1、m、n、n+1的节点，反转完成后，让m-1指向n，让m指向n+1。最后要注意当m=1时，最后要返回的是n节点，当m!=1时，要返回的是头节点。")]),_._v(" "),v("p",[_._v("时间复杂度O(n)，空间复杂度O(1)。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("关键词")]),_._v("："),v("code",[_._v("类似于普通反转")]),_._v("，"),v("code",[_._v("m-1、m、n、n+1")]),_._v("，"),v("code",[_._v("注意m=1的情况")]),_._v("。")])]),_._v(" "),v("h3",{attrs:{id:"_4、合并两个排序的链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、合并两个排序的链表"}},[_._v("#")]),_._v(" 4、合并两个排序的链表")]),_._v(" "),v("p",[v("strong",[_._v("题目")]),_._v("：")]),_._v(" "),v("p",[_._v("输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。")]),_._v(" "),v("p",[_._v("数据范围： 0≤n≤1000，−1000≤节点值≤1000\n要求：空间复杂度 O(1)，时间复杂度 O(n)")]),_._v(" "),v("p",[_._v("如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}")]),_._v(" "),v("p",[v("strong",[_._v("解法1")]),_._v("：")]),_._v(" "),v("p",[_._v("创建一个临时节点head，让cur指针指向head，同时遍历两个链表，并比较它们的节点，让cur指向其中的较小者，并将较小者作为新的cur，直到某一链表节点为空，此时让该链表的尾节点指向另一个链表剩下节点中的第一个节点，最后返回head.next即可。")]),_._v(" "),v("p",[_._v("时间复杂度O(n)，空间复杂度O(1)。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("关键词")]),_._v("："),v("code",[_._v("临时节点head")]),_._v("，单指针"),v("code",[_._v("cur")]),_._v("，"),v("code",[_._v("pre指向min(phead1, phead2)")]),_._v("，"),v("code",[_._v("min(phead1, phead2)又作为新的pre")]),_._v("，"),v("code",[_._v("链表1的尾节点指向链表2剩下的节点")]),_._v("。")])]),_._v(" "),v("p",[v("strong",[_._v("解法2")]),_._v("：")]),_._v(" "),v("p",[_._v("递归。如果其中一个链表为空，返回另一个链表；如果都不为空，比较head1和head2，假如head1<head2，则head1作为头节点，head1的下一个节点就是head1.next与head2中的较小者，否则就是head2作为头节点，head2的下一个节点就是head2.next与head1中的较小者，用这种方式来递归。")]),_._v(" "),v("p",[_._v("时间复杂度O(n)，空间复杂度O(n)。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("关键词")]),_._v("："),v("code",[_._v("递归")]),_._v("。")])]),_._v(" "),v("h3",{attrs:{id:"_5、合并k个已排序的链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、合并k个已排序的链表"}},[_._v("#")]),_._v(" 5、合并k个已排序的链表")]),_._v(" "),v("p",[v("strong",[_._v("题目")]),_._v("：")]),_._v(" "),v("p",[_._v("合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。")]),_._v(" "),v("p",[_._v("数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣<=1000")]),_._v(" "),v("p",[_._v("要求：时间复杂度 O(nlogn)")]),_._v(" "),v("p",[v("strong",[_._v("解法")]),_._v("：")]),_._v(" "),v("p",[_._v("以合并两个有序链表的方法为基础，通过递归分而治之，每次递归时将数组一分为二，直到分成两个或者一个元素，若分成两个元素，则返回它们的合并结果，若分成一个元素，则返回该元素。")]),_._v(" "),v("p",[_._v("时间复杂度O(nlog n)，空间复杂度O(log n)。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("关键词")]),_._v("："),v("code",[_._v("递归")]),_._v("，"),v("code",[_._v("二分法")]),_._v("，"),v("code",[_._v("分而治之")]),_._v("，"),v("code",[_._v("以合并两个有序链表的方法为基础")]),_._v("。")])])])}),[],!1,null,null,null);v.default=n.exports}}]);